// SPDX-License-Identifier: CC0-1.0
//
// SPDX-FileContributor: Antonio Niño Díaz, 2023
// SPDX-FileContributor: Ivan Veloz, 2024

#ifndef ARM9
#define ARM9
#endif

#include <stdbool.h>
#include <stdio.h>
#include <time.h>

#include <nds.h>
#include <maxmod9.h>

#include "common.h"

// Headers autogenerated when files are find inside AUDIODIRS in the Makefile
#include "soundbank.h"
#include "soundbank_bin.h"

// Header autogenerated for each PNG file inside GFXDIRS in the Makefile
#include "neon.h"

// Header autogenerated for each BIN file inside BINDIRS in the Makefile
#include "data_string_bin.h"

#include "lvgl/lvgl.h"
#include <time.h>
#include "lvgl/examples/lv_examples.h"
#include "lvgl/demos/lv_demos.h"
#include "dslvgl.h"

#define DMA_CH_MAIN 3
#define DMA_CH_SUB  2

const size_t dispsize = 256*192;
const size_t fbsize = dispsize*sizeof(uint16_t);
int bg;

dslvgl_framebuffer_t fbmain;
dslvgl_framebuffer_t fbsub;

void lvgl_tick_isr () {
    lv_tick_inc(1);
}

void lvgl_vblank_isr() {
    if(comutex_try_acquire(&fbmain.mutex)) {
        assert(dmaBusy(DMA_CH_MAIN) == false);
        dmaCopyHalfWords(DMA_CH_MAIN, fbmain.buffer, bgGetGfxPtr(fbmain.bgid), fbsize);
        comutex_release(&fbmain.mutex);
    } /*
    if(comutex_try_acquire(&fbsub.mutex)) {
        assert(dmaBusy(DMA_CH_SUB) == false);
        dmaCopyHalfWords(DMA_CH_SUB, fbsub.buffer, bgGetGfxPtr(fbsub.bgid), fbsize);
        comutex_release(&fbsub.mutex);
    }*/
    // If a mutex can't be acquired, it's because the back buffer is being 
    // written to. In that case we skip rendering a frame.
    // The lowest DMA channel number gets priority until the transfer 
    // is complete.
}


void lvgl_touch_cb(lv_indev_t * indev, lv_indev_data_t * data) {
    if(keysCurrent()&KEY_TOUCH) {
        touchPosition pos;
        touchRead(&pos);
        data->point.x = pos.px;
        data->point.y = pos.py;
        data->state = LV_INDEV_STATE_PRESSED;
    } else {
        data->state = LV_INDEV_STATE_RELEASED;
    }
}

static void swap_framebuffer(int bg) {
    if (bgGetMapBase(bg) == 8)
        bgSetMapBase(bg, 0);
    else
        bgSetMapBase(bg, 8);
}

inline void swap_rgb565_bgr555(uint16_t * src, uint16_t * dst) {
    *dst = ((*src&0xF800)>>11) | ((*src&0x07C0)>>1) | ((*src&0x001F)<<10) | 0x8000;
}

void lvgl_flush_cb(lv_display_t * display, const lv_area_t * area, uint8_t * px_map) {

    while(dmaBusy(DMA_CH_MAIN)) {LV_LOG_TRACE("dma");}  // just in case DMA isn't done yet
    comutex_acquire(&fbmain.mutex);
    uint16_t * wrkbuf = fbmain.buffer;

    const int32_t hres   = lv_display_get_horizontal_resolution(display);
    uint16_t     *srcbuf = (uint16_t *)px_map;
    // for every line in the area
    for(uint16_t *l = wrkbuf+hres*area->y1; l <= wrkbuf+area->y2*hres; l+=hres) {
        // for every pixel in the line
        for(int32_t p = area->x1; p <= area->x2; p++) {
            swap_rgb565_bgr555(srcbuf, l+p);
            srcbuf++;
        }
    }

    
    if(lv_display_flush_is_last(display)) {
        // for dual displays, put both dmaCopy on the VBlank interrupt.
        // finished
        // needs a mutex
        //swiWaitForVBlank();
        //dmaCopyHalfWords(3, wrkbuf, bgGetGfxPtr(bg), dispsize*sizeof(uint16_t));

    }
    comutex_release(&fbmain.mutex);
    lv_display_flush_ready(display);
}

// Callback called whenver the keyboard is pressed so that a character is
// printed on the screen.
void on_key_pressed(int key)
{
   if (key > 0)
      printf("%c", key);
}

int main(int argc, char **argv)
{
    int r;
    lcdSwap();
    r = dslvgl_driver_init(DSLVGL_INIT_MAIN);
    assert(r == 0);
    
    // Setup sub screen for the text console
    consoleDemoInit();
    printf("ready\n");

    /* LVGL STUFF */
    // Initialize LVGL
    lv_init();
    
    // Setup tick timer, 1ms period
    timerStart(0,ClockDivider_1,timerFreqToTicks_1(1000),dslvgl_tick_isr);

    lv_display_t * displaymain = lv_display_create(256, 192);
    lv_display_set_flush_cb(displaymain, dslvgl_main_flush_cb);
    lv_display_set_buffers(
        displaymain, 
        dslvgl_driver_get_buf(DSLVGL_DISP_MAIN), 
        NULL, 
        dslvgl_driver_get_buf_size(DSLVGL_DISP_MAIN), 
        dslvgl_driver_get_render_mode(DSLVGL_DISP_MAIN));

    // Register touchscreen as input device
    lv_indev_t * indev = lv_indev_create();
    lv_indev_set_type(indev, LV_INDEV_TYPE_POINTER);
    lv_indev_set_read_cb(indev, lvgl_touch_cb);

    //lv_example_get_started_1();
    lv_example_anim_2();
    //lv_example_get_started_2();
    //lv_demo_benchmark();
    irqSet(IRQ_VBLANK, dslvgl_vblank_isr);
    irqEnable(IRQ_VBLANK);


    /* END OF LVGL STUFF */


    // Load demo keyboard
    Keyboard *kbd = keyboardDemoInit();
    kbd->OnKeyPressed = on_key_pressed;

    // Setup sound bank
    mmInitDefaultMem((mm_addr)soundbank_bin);

    // load the module
    mmLoad(MOD_JOINT_PEOPLE);

    // load sound effects
    mmLoadEffect(SFX_FIRE_EXPLOSION);

    // Start playing module
    mmStart(MOD_JOINT_PEOPLE, MM_PLAY_LOOP);

    int angle_x = 0;
    int angle_z = 0;
    char name[256] = { 0 };

    while (1)
    {
        // Synchronize game loop to the screen refresh
        //swiWaitForVBlank();

        // Call LVGL periodic task (timer handler), on a while(1), by the book.
        lv_timer_handler();

        // Print some text in the demo console
        // -----------------------------------
        /*
        consoleClear();

        // Print current time
        char str[100];
        time_t t = time(NULL);
        struct tm *tmp = localtime(&t);
        if (strftime(str, sizeof(str), "%Y-%m-%dT%H:%M:%S%z", tmp) == 0)
            snprintf(str, sizeof(str), "Failed to get time");
        printf("%s\n\n", str);

        // Print contents of the BIN file
        for (int i = 0; i < data_string_bin_size; i++)
            printf("%c", data_string_bin[i]);
        printf("\n");

        // Print some controls
        printf("PAD:    Rotate triangle\n");
        printf("SELECT: Keyboard input test\n");
        printf("START:  Exit to loader\n");
        printf("A:      Play SFX\n");
        printf("\n");

        // Test code from a different folder
        printf("Name: [%s]\n", name);
        printf("Name length: %d\n", my_strlen(name));
        */
        // Handle user input
        // -----------------

        scanKeys();

        uint16_t keys = keysHeld();
        uint16_t keys_down = keysDown();

        if (keys & KEY_LEFT)
            angle_z += 3;
        if (keys & KEY_RIGHT)
            angle_z -= 3;

        if (keys & KEY_UP)
            angle_x += 3;
        if (keys & KEY_DOWN)
            angle_x -= 3;

        if (keys_down & KEY_A)
            mmEffect(SFX_FIRE_EXPLOSION);

        if (keys & KEY_SELECT)
        {
            consoleSetCursor(NULL, 1, 12);
            printf("Type your name: ");
            scanf("%255s", name);
        }

        if (keys & KEY_START)
            break;

    }

    return 0;
}
